Intro
-----

Arduino programs canbe divided in three main parts

   - Structure
      consists with 2 main functions
         1. Setup() function
            called when a sketch starts.
            use it to initialize the variable, pinModes, start using libraries

             after each power up or reset of Arduino board, only run once
         2. Loop() function
            After creating a setup() function, loop() function dies precisely what its name suggersts.
            and loops consecutively.

   - Values(variables and constants)
   - Functions
 
DEFINITIONS:: WIKIPEDIA
-----------------------

Cathode
   using the memory device(mnemonic) CCD for Cathode-Current-Departs.
   conventional current describes the direction in which positive charges move.
   Electrons Have a negative electrical chargem so the movement of eletrons is opposite to that of conventional current flow.
   Consequently, the mnemonic cathode current departs also means that electrons flow into the device's cathode from external circuit.
   The eletrode through which conventional current flows the other way, into the device, is termed an *anode.*

Anode
   anode is electrode though which the conventional current enters into polarized electrical device.
   this contrasts with cathode, and electrode through which conventional current leaves an electrical device.
   a common mnemonic is ACID, for "Anode Current into device".
   direction of conventional current (flow of positive charges) in circuit is opposite to the direction if electron flow,
   so (negatively charged) electrons flow out the anode of galvanic cell, into the circuit.

   in electrolytic cell, the anode is the wire or olate having excess positive charge.
   Consequently, anions will tend to move towards the anode where they can undergo oxidation.
   historically, anode has been known as the zincode.

Electronics
   Creation of eletronic requires knowledge of physics and device technology for
   emission and flow control of electrons in vacuum and matter.
   uses active devices to control electron flow by amplification and rectification,
   which distinguishes it from classical electrical engineering which uses
   pass effects such as *resistance* *capacitance* *inductance* to control current flow.
   
   identification of the eletron in 1897, along wuth subsequent invention of vaccum tube,
   which could amplify and rectify small electrical signals, inargurated the field of electronics and electron age.

Inductance
    tendency of an electrical conductor to oppose a change in electric current flowing through it.

Rectifier
   electrical device that converts alternating current(AC), which periodically reverses direction to,
   direct current(DC), which flows in only one direction.

Electrode
   electrical conductor used to make contact with nonmetalic part of a circuit(e.g. a semiconductor, electrolyte, vacuum, or air).
   The word was coined by William Whewell at the request of the scientist Michael Faraday from two Greek Words:

      - elecktron(an amber, which electricity is derived)
      - hodos(a road)

Electrical Conductor
   conductor is an object or type of material that allows the flow of charge(electrical current) in one or more directions.
   Materials make of metal are common electrical conductors.

Electrical Current
   is generated by the flow of negatively charged **electrons,**
   postively charged **holes,** and positive or negative ions in some cases.

Peripheral
   An Ancillary device used to put information into and get information out of the computer.
   Several categories of peripheral devices may be indentified, based on their relationship with computer::

      - *input device* sends data or instructions to the computer such as mouse, keyboard, camera, and read-only memory.
      - *output device* provides output from the computer, such as monitor, printer, headphones
      - *input/output device* performs both input and output functions, such as data storage device(disk drive, usb, flash drive)

   modern devices, such as internet-enabled digital watches, keyboards, tablet computers have interfaces for use as computer peripheral devices.

ARDUINO & IOT REFERENCES
------------------------

Microcontroller(MCU)
   conpact integrated circuit, designed to govern specific operation in an embedded system.
   A typical microcontroller includes a processor, memory and I/O peripheral on single chip.
   


I2C - I2C Bus Interface and Protocol
   I2C is Serial protocol for two-wire interface to connect low-speed devices like::

      - Microcontrollers
      - EEPROMs
      - A/D and D/A converters
      - I/O interfaces
      - other simmilar peripherals in embedded systems

   Each I2C slave device needs an address - they must still be obtained from NXP(formerly philps semiconductors).
   I2C bus is popular because it is simple to use, ther can be more than one master, only upper bus speed is defined and
   only two wires with pull-up resistors are needed to connect almost unlimited number of I2C devices.
   I2C can use even slower microcontrollers with general-purpose I/O pins since,
   they only need to generate correct *Start and Stop conditions* in addition to functions for read and write a byte.

I2C Bus
-------

https://i2c.info/

typical embedded system consists of one or more microcontrollers and peripheral devices like memories, converter, I/O expanders, LCD drivers, sensorsm matrix switches, etc.
the complexity and the cost of connecting all those devices together must be kept to a minimum.
the system must be designed in such a way that slower devices can communicate with system without slowing down faster ones.

to satisfy these requirements a *serial bus* is needed.
A bus means specification for the connections, protocl, formats, addresses and procdfure that define rules on the bus.

The I2C bus uses two wires::

   - serial data(SDA)
   - serial clock(SCL)

All I2C master and slave devices are connected with only those two wires. 
Each device can be a trnsmmitter, a receiver or both.
some devices are masters - they generate bus clock and initiate communication on the bus,
other devices are slaves and respond to the commands on the bus.
in order to communicate with specific device, eache slave device must have an address which is unique on the bus.
I2C master devices(usually microcontrollers) dont need an address since no other (slave)device sends commands to the master.

Bus Signals
^^^^^^^^^^^

   Both signals (SCL and SDA) are bidirectionl. they connected via resistors to positive power supply voltage.
   this means that when the *bus is free, both lines are high.*
   All devices on the bus must have open-collector or open-drain pins.
   Activation the line means pulling it down (wired AND). the number of the devices on a single bus is almost unlimited::

      the only requirement is that the bus capacitance does not exceed 400pF.
      because logical 1 level depends on supply voltage, there is no standard bus voltage.

Serial Data Transfer
^^^^^^^^^^^^^^^^^^^^

   For each clock pulse ine bit of data is transferred.
   the SDA signal can only change when the SCL signal is low - when the clock is high the data should be stable.

Start and stop conditions
^^^^^^^^^^^^^^^^^^^^^^^^^

   Each I2C command initiated by master device starts with a **START condition** and ends with a **STOP condition.**
   for both conditions SCL has to be high. A high to low transition of SDA is considered as **START** and low to high transition as **STOP.**
   After the Start condition, the bus is considered as busy and can be used by another master only after a Stop condition is detected.
   After Start contidion the master can generate a repeared Start.
   this is equivalent to a normal Start and is ususally followed by the slave I2C address.

   Microcontrollers that have dedicated I2C hardware can easily detect bus changes and behave also as I2C slave devices.
   However, if the I2C communication is implemented in software, the bus signals must be sampled at least two times per clock cycle in order to detact necessary changes.

I2C Data Transfer
^^^^^^^^^^^^^^^^^

   Data on I2C bus is transferred in 8-bit packets. there is no limitation on number of bytes,
   however, each byte must be followed by an ACK bit.
   if slave device does not acknowledge transfer this means, that there is no more data or device


Sketch build process
--------------------

Overview
^^^^^^^^

1. Arduino development software performs some minor pre-proceesing to turn your sketch into a cpp program.
#. depecdancies of sketch are located.
#. it then gets passed to compiler(avr-gcc), which turns code to machine readable instructions or object file.
#. your code gets linked with the standard Arduino libraries that provide basic functions like ``digitalWrite()`` or ``Serial.print()``.
#. result is single intel hex file.

   - contains specific bytes that need to be written to th program memory of the chip on Arduino board.

#. this file is then uploaded to the board

   - transmitted over USB or serial connection via the bootloader already on the chip or extermnal hardware.

Pre-Processing
^^^^^^^^^^^^^^

Arduino development software performs a few transformations to your sketch before passing it to avr-gcc compiler

   1. All .ino and pde file in sketch folder and concatenated together
      strating wiht the file and matches the folder name by the other
      in alphabetical order and cpp extention is added to the filename.
   #. if not already present, ``#include <Arduino.h>`` is added to sketch.
      this header file includes all the definitions needed for standard Arudino core.
   #. Prototypes are generated for all function definition in .ino/.pde files
      that dont already have prototypes. in some rare cases
      prototype generation may fail for some functions. to work around this,
      you can provide your own prototypes for these functions
   #. ``#line`` directives are added to make warning 
      or error messages reflect the original sketch layout.

No pre-processing is done to files in sketch with any extension
other than .ino or .pde. Additionally .h files in the sketch
are not automatically #included from the main sketch file.
Further, if you want to call functions defined in a .c file from .cpp file,
you'll need to wrap this declaration in an ``extern "C" {}`` block
that is defined only inside of C++ files.  

I/O Functions
-------------

pins can configured as input or output.

.. note::

   very important to note that majority of Arduino analog pins.

Pins confiugured as INPUT
^^^^^^^^^^^^^^^^^^^^^^^^^

| arduino pins are default configured as input.
| 아두이노 핀들은 기본값으로 input pin으로 설정되어있다.
| pins configured this way are said to be in a high-impedance state. equivalent to series resistor of 100 megaohm in front of the pin.
| 이러한 방식으로 설정된 핀들은 고저항 상태에 있는 것으로 말해진다. 연속적으로 100megaohm이 핀 앞에 있는 것과 동일하다.
| this means that it takes very little current to switch the input pin from one state to another.
| 이것은 그들의 상태를 바꾸기 위해서는 아주 적은 전류가 흐르게 된다는 것이다.
| this makes the pins useful for such tasks as implementing a capacitive touch sensor or reading an LED as a photodiode.
| photodiode(빛을 전기 흐름으로 바꾸는 semiconductor)로서 led를 읽게 하거나 정전용량 센서를 구현하는데 유용하게 작용한다.
| Pins configured as pinMode(pin, INPUT) with notthing connected to them, or with wires connected to them that are not connected to other circuits
| 입력핀으로 설정되었으나 아무것도 연결되어있지 않은 핀들,
| these pins report seemingly random changes in pin state, picking up electrical noise from environment, or coupling the state of a nearby pin.
| 이러한 핀들은 임의의 변화를 핀상태에서 보고하며, 환경에서부터 전기적 노이즈를 수령하거나, 주변핀의 상태에 영향을 받는다.

Pull-up Resistors
^^^^^^^^^^^^^^^^^

pull-up resistors are often useful to steer an input pin to known state if no input is present.
이것은 pullup resistor를 +5V로 input에 더하거나, pulldown resistor를 ground로 향하게 하여 input에 더하는 것으로 이루어 질 수 있다,
10K resistor는 pullup pulldown resistor에게 좋은 value.

*using Built-in Pull-Up resistor with Pins Configured as input*

Atmege chip에 20000 pullup resistors가 내장되어 있어 코드로 접근할 수 있다.
이 builtin pullup resistors는 ``pinMode()`` 를 ``INPUT_PULLUP`` 으로 설정하는 것으로 접근할 수 있다.
이것이 효과적으로 INPUT 모드를 반전 할 수 있다. 
the value of this pullup depends on microcontroller에 달린다.
대부분의 AVR보드에서 이 값은 20kohm ~ 5-kohm으로 보장된다.

센서를 핀으로 INPUT_PULLUP으로 설정한 pin으로 연결할 때, 반대편은 gnd로 연결되어야 한다.
simple switch case, switch open -> read HIGH, switch pressed -> read LOW.
pullup resistors provide enough current to light an LED dimly connected to pin configured as input.
만약 LED가 아주 약하게 동작하는 것으로 보인다면, 제대로 동작하는 것이다.

내부 칩 메모리주소가 같은 same registers, controls whether pin is HIGH or LOW,가 control the pullup registors.
동시에 pin is in INPUTmode일때 turned on 된 pullup resistors를 가진 핀이 
will have the pin configured as HIGH, if pin is then switched to OUTPUT mode with ``pinMode()``.

.. code-block:: arduino

   pinMode(3, INPUT); // set pin to input without using built in pullup resistor.
   pinMode(5, INPUT_PULLUP);

*Pins Configured as output*

``pinMode()`` 로 OUTPUT으로 설정된 핀들은 said to be in low-impedance state.
이는, 그들으 잠재적으로 많은 전류를 다른 서큣로 전달 할 수 있다는 것.
Atmega pins는 can source (provide positive current) or sink (provide negative current) up to 40mA of current to other circuits.
20mA 이면 잘 동작하는 LED엔 충분하며, also run many sensors but not enough current to tun relays, solenoids, or motors.

from outpins, attempting to run high current device는 output transistors in pin, entire Atmega chip을 손상시킬 수 있다.
이러한 이유로, it is good idea to connect the OUTPUT pins to other devices through 470ohm or 1k resistors, unless
그렇지 않으면 maximum current drwawn from the pins is required for particular application.

pinMode() Function
^^^^^^^^^^^^^^^^^^

``pinMode()`` function is used to configure a specific pin to behave
either as an input or an output. it is possible to enable the 
internal pull-up resistors with the mode INPUT_PULLUP.
Additionally, the INPUT mode explicitly disables the internal pull-ups

.. code-block:: arduino

   int button   = 5;
   int LED      = 6;

   void setup()
   {
       pinMode(button, INPUT_PULLUP);
       // set the digital pin as input with pull-up resistor

       pinMode(button, OUTPUT);
       // set the digital pin as output
   }

   void loop()
   {
       if (digitalRead(button) == LOW) // if button pressed : button as INPUT_PULLUP
       {
           digitalWrite(LED, HIGH); // turn on led : button as OUTPUT
           delay(500);
           digitalWrite(LED, LOW); // turn off led
       }
   }

- pin: the number of the pin whose mode you wish to set
- mode: INPUT, OUTPUT, INPUT_PULLUP

digitalWrite() Function
^^^^^^^^^^^^^^^^^^^^^^^

used to write a HIGH or LOW value to digital pin.
if pin has been configured as an OUTPUT with ``pinMode``,
its voltage will be set to corresponding value:
5V or 3,3V on boards. for HIGH 0V for LOW.
if, the pin is configured as an INPUT, digitalWrite will 
enable(HIGH) or disable(LOW) the internal pullup on the input pin.
it is recommended to set the pinMode to INPUT_PULLUP to enable the internal pull-up resistor.

